# Linux 학습 정리 II

## 알고 쓰는 리눅스 명령어

### 정규 표현식

- **정규 표현식(Regular expression. 정규식)** : **특정한 규칙**을 가진 **문자열의 집합**을 표현하는 데 사용하는 일종의 형식 (**검색** 또는 **치환**에 사용됨)



| 메타 문자 | 의미                                                         | 메타 문자 | 의미                                                         |
| --------- | ------------------------------------------------------------ | --------- | ------------------------------------------------------------ |
| ^         | 문자열의 시작                                                | \d        | 숫자                                                         |
| $         | 문자열의 끝                                                  | \D        | 숫자가 아닌 것                                               |
| .         | 하나의 문자와 대응                                           | \w        | 알파벳 대소문자, 숫자, 언더스코어(_), `[a-zA-Z0-9_]`와 같은 의미 |
| \s        | 공백문자                                                     | \W        | \w에 해당하지 않는 글자                                      |
| \S        | 공백문자가 아닌 것                                           | \n        | 개행문자                                                     |
| \         | 메타 문자를 문자 그대로 사용                                 | \t        | 탭(tab) 문자                                                 |
| \b        | word boundary, 즉 단어구분자(띄어쓰기 white space..)를 찾아줌 |           |                                                              |

### 선택 패턴

- `|`  문자를 이용하면 `A|B` 의 패턴으로 매칭 가능하다. 예를 들어 `alice|elice` 라는 정규 표현식은 `"alice"`와 `"elice"` 라는 문자열을 모두 포함한다. 즉, `alice` 도는 `elice` 둘 중 하나라는 뜻

- `[]` : 대괄호 속에 넣은 문자 중에 하나에 매칭

  ```
  [a,b,c] // a, b, c 후보 중에 하나라도 매칭되면 됨
  ```

  

- `[0-9]` : 0부터 9까지 숫자 하나에 매칭

- `[A-Z]` : A부터 Z까지의 알파벳 대문자 하나에 매칭

  - `[]` 내에서 `^` 기호는 **not**의 의미를 가진다.

- [a-z] : a부터 z까지의 알파벳 소문자 하나에 매칭

### 수량 한정자

| 수량자 | 의미         | 수량자 | 의미               |
| ------ | ------------ | ------ | ------------------ |
| ?      | 0개 또는 1개 | { n }  | n개                |
| *      | 0개 이상     | {n, m} | n개 이상, m개 이하 |
| +      | 1개 이상     | {n, }  | n개 이상           |

### 그룹 패턴

**`()`** 괄호는 **그룹**을 나타낸다. 그룹은 전체 패턴 내에서 하나로 묶여지는 패턴을 말하며, 한 번 생성한 그룹은 **재사용**이 가능하다. 만들어진 순서대로 `\1`, `\2`, `\3`으로 참조 가능하다. 예를 들어 `(to)ma\1`은 `tomato`와 매칭된다.

### 정규 표현식 사용 예

- 전화번호는 **일정한 패턴**을 가진 문자열이다.
  - 전화번호는 010으로 시작한다.
  - 전화번호의 가운데 자리는 네 자리이다.
  - 전화번호의 각 자리에 구분문자가 있을 수도 있고, 없을 수도 있다.
- **`^010(\D?\d{4}){2}`**
  - `^` : 시작 문자는 010
  - `\D?` : 숫자가 아닌 문자가 0개 이상
  - `\d{4}` : 숫자 4개
  - `(\D?\d{4}){2}` : 앞의 그룹이 2개 존재
  - 또는 **`^010(\D?\d{4}\1)`** 로도 표현 가능

## GREP

- **grep** : **global regular expression print**의 약자로, 파일 내에서 지정한 패턴이나 문자열을 찾은 후에 그 **패턴을 포함하고 있는 모든 행을 출력**한다.
- **사용법**

```sh
grep [option] [pattern] [파일명]
```

- -option
  - `-i` : 대소문자를 구분하지 않고 검색
  - `-v` : 패턴과 **일치하지 않는 행**을 출력
  - `-c` : 패턴과 **일치하는 행의 개수**를 추력
  - `-w` : 패턴과 **단어 단위로 매칭**되어야 출력

- **예시**

```sh
grep elice hello.txt

// hello.txt 파일에서 'elice'라는 문자열이 들어 있는 행을 모두 출력
```

```sh
grep -c elice hello.txt

// hello.txt 파일에서 'elice'라는 문자열이 들어 있는 행의 수 출력
```

```sh
grep [0-9] hello.txt

// hello.txt 파일에서 숫자가 존재하는 행을 모두 출력
```

```sh
grep "Elice\.The\.Rabbit" *

// 현재 모든 디렉토리의 모든 파일에서 Elice.The.Rabbit을 찾아 출력
```

```sh
grep -v ^# somecode

// somecode 파일에서 #으로 시작하지 않는 행을 모두 출력
```

```sh
grep '\<[a-z].*e\>' elice

// elice 파일에서 <소문자로 시작하고 공백을 포함한 여러 문자가 나오며, e>로 끝나는 단어가 포함된 행을 모두 출력 
```

### Standard Stream

- 일반적으로 표준 입력, 표준 출력, 표준 오류 출력으로 분류함. 스트림은 문자열로 콘솔에 출력되도록 설정되어 있음
- `stdin` : 키보드 입력, `stdout` : 화면 출력, `stderr` : 오류 내용 출력

### File Redirection

- **File Redirection** : 표준 스트림의 흐름을 바꾸어 일반적인 표준 입력 및 출력 그리고 오류를 사용하지 않고 다른 경로인 파일로 재지정하는 것을 뜻함

- **사용 예시**

  ```sh
  cat < hello.txt > elice.txt
  
  1. hello.txt의 내용을 cat 명령어의 입력 스트림으로 전송
  2. cat 명령어는 hello.txt 파일의 내용을 출력
  3. cat 명령어의 출력 스트림을 elice.txt로 변경
  4. cat 명령어의 출력 스트림은 화면이 아닌 elice.txt에 저장
  ```

- 표준 오류는 연산자를 사용하지 않으며 파일디스크립터 **번호를 `>` 앞에** 작성해서 사용함

  - `0>` : 표준 입력, `1>` : 표준 출력, `2>` : 표준 에러

### Piping commands

- **Pipe** : 둘 이상의 명령어를 묶어 출력의 결과를 다른 명령으로 전환할 수 있는 기능이다. 명령어의 표준 출력을또 다른 명령어의 표준 입력으로 연결할 수 있다. `|` 기호를 사용하여 명령어와 명령어를 연걸한다.

- **사용 예시**

  ```sh
  head a.txt | grep [0-9]
  
  1. head 명령을 실행하여 a.txt의 첫 10줄을 출력
  2. 출력된 결과를 |(pipe)를 통해 grep 명령으로 전달
  3. 숫자가 포함된 행을 가진 행의 결과가 모두 출력
  ```

  **Pipe & Redirection**

  ```sh
  ls | grep user01 > output.txt
  
  1. ls 명령을 실행 (현재 디렉토리의 디렉토리/파일명 출력)
  2. ls 명령의 결과를 입력 값으로 한 grep 명령어 실행
  3. user01이라는 이름을 가진 파일의 결과가 출력
  4. grep 명령어의 출력 스트림은 output.txt에 저장
  ```

### File Redirection과 Pipe의 차이점

- **File Redirection**에서는 파일을 표준 스트림으로 사용했다면, **Pipe**는 각 프로세스가 다른 프로세스를 표준 입력 스트림으로 사용한다는 점이 다르다.

  ```sh
  // File Redirection
  python add.py < input.txt
  
  // Pipe
  cat input.txt | python add.py
  
  결과는 같으나 방법이 다름
  ```

## 마운트

### mount

- **mount** : 물리적인 저장 장치(보조기억장치)를 디렉토리(또는 폴더)에 연결시켜주는 것을 말한다. 
- 윈도우에서는 하드, USB 등의 보조기억장치를 연결하면 자동으로 폴더(디렉토리)에 연결된다. (이것을 PnP(Plug and Play)라고 한다) 

- 리눅스의 경우 PnP 기능이 작동하지 않아 직접 연결해야 한다. 즉, 보조기억장치를 설치했을시 mount 작업을 해야 가능하다.

```sh
mount [option] [device] [directory]
```

- -option
  - `-a` : /etc/fstab에 명시된 파일 시스템을 마운트할 때 사용
  - `-t` : 파일 시스템의 유형을 지정, 생략할 시 /etc/fstab 파일을 참조
  - `-o` : 추가적인 설정을 적용할 때 사용, 다수의 조건을 적용할 땐 콤마(,)로 구분

```sh
remount [device] [directory]
```

- **remount** : mount를 취소하는 명령어

```sh
df
```

- **df** : 현재 mount된 디스크 정보 추력

```sh
fdisk -l
```

- **fdisk -l** : 디바이스의 파일 시스템 이름

## 리눅스 프로세스와 네트워크

### 프로세스

리눅스 시스템에서 메모리에 적재되어 실행되고 있는 모든 프로그램이 프로세스이다.

- **프로그램** : 코드를 이용하여 만든 코드 명령어 집합체
- **프로세스** : **실행**되고 있는 프로그램

### 리눅스 프로세스 특징

- 모든 프로그램은 실행될 때 **하나 이상의 프로세스**를 갖는다.
- **병행**적으로 실행이 가능하다.
- 부모 자식 프로세스가 있게 된다.
- 커널에 의해 관리된다.
- 모든 프로세스에는 소유자가 있다.
- 프로세스마다 식별을 위한 ID(PID)가 부여된다.

### PID, 프로세스 고유 번호

- 모든 프로세스는 고유한 번호(PID)를 갖는다. 
- **PID 1번**은 **init 프로세스**, 
- **PID 2번**은 **kthreadd 프로세스**가 실행된다. 
- init 프로세스는 나머지 모든 시스템 프로세스의 부모 프로세스이고, thread 프로세스는 모든 스레드의 부모 프로세스이다.
- 프로세스는 shell이 아닌 **커널**에 의해 관리된다.

### 프로세스의 메모리 구성

 

| 영역            | 내용                                                         |
| --------------- | ------------------------------------------------------------ |
| **코드 영역**   | 프로그램 코드 자체를 구성하는 메모리의 영역으로 하위 메모리부터 할당됨(0x00..) |
| **데이터 영역** | 전역 변수와 정적 변수, 배열, 구조체 등 초기화 된 변수들이 저장됨 |
| **BSS 영역**    | 초기화되지 않은 변수가 저장됨 / 프로그램이 실행될 때 생성되고, 종료될 때 반환됨 |
| **힙 영역**     | **동적인 메모리** 할당 영역, 낮은 주소로부터 높은 주소로 쌓이는 형태 |
| ...             |                                                              |
| **스택 영역**   | 함수 매개변수, 복귀 주소, 지역 변수와 같은 임시 자료 / 함수 호출시 생성되고, 종료될 때 제거됨 / LIFO 방식으로 동작함 |
| **커널**        | 사용자가 저근할 수 없는 영역                                 |

## 프로세스 명령어

### 프로세스 목록 보기 : ps

```sh
ps [option]
```

- option
  - `-e` : 현재 실행 중인 모든 프로세스 정보 출력
  - `-f` : 모든 (속성) 정보 확인
  - `-a` : 실행중인 전체 사용자의 모든 프로세스 출력
  - `-u` : 프로세스를 실행한 사용자와 프로세스 시작 시간 등을 출력
  - `-x` : 터미널 제어 없이 실시간으로 프로세스 현황 보기

```sh
// 모든 프로세스 리스트 확ㅇ니
$ ps -ef

UID | PID | PPID | C | STIME | TTY |   TIME   | CMD
root | 1  |   0  | 0 | 06:34 |  ?  | 00:00:02 | /sbin/init splash
root | 2  |   0  | 0 | 06:34 |  ?  | 00:00:00 | [kthreadd]


// 시스템에서 실행 중인 모든 프로세스 출력
$ ps -aux
```

 ### 프로세스 종료 : kill

```sh
kill [option] [PID:프로세스 아이디]
```

- option
  - `-l` : 사용 가능한 **시그널 목록**을 출력
- 자주 사용하는 시그널
  - `-1` : **재실행**(SIGHUP)
  - `-9` : **강제 종료**(SIGKILL)
  - `-15` : **정상** 종료(SIGTERM)

## Job

- **백그라운드**로 실행되는 작업을 보여주는 명령어 (`&` 를 명령어 마지막에 붙여 job을 실행할 수 있다)
- job은 프로세스와 달리 **터미널 명령을 통한 작업만을 의미**
- job을 통해 프로세스를 실행할 수 있지만 터미널이 종료되면 job과 함께 프로세스도 종료된다. (터미널에 굉장히 의존적임)
- 각각의 터미널마다 job은 따로 존재한다.
- foreground와 background로 작업을 나누어 실행하면 좀더 효율적으로 프로세스를 관리할 수 있다.

### job 실행 / 목록 출력 / 정료

```sh
// 실행
// [작업 명령어] &
$ sleep 500 &
[1] 2292
$ sleep 700 &
[2] 2293

// 목록 출력
$ jobs
[1] - Running      sleep 500 &
[2] + Running      sleep 700 &


// 종료
$ kill %1
[1] - Terminated      sleep 500
[2] + Running      sleep 700 &

// kill %작업번호
// ps 명령어를 통해 PID를 알아내어 종료하는 방법도 가능
```

## 리눅스 작업 예약 명령어

### at

- **at** : 지정된 시간에 1회 실행되는 작업 예약 명령어이다. 시간이 되면 수해오디고 작업 리스트에서 사라진다.

  ```sh
  at [옵션] [시간] [날짜] [+증가 시간]
  ```

  - **option**
    - `-m` : 출력 결과가 없더라도 작업이 완료될 때 사용자에게 **메일**을 보냄
    - `-f` : **스크립트 파일** 등을 실행할 때 사용
    - `-l` : 예약된 **작업 목록** 출력, **`atq`** 명령어 또한 같은 동작을 수행
    - `-v` : 작업이 수행될 **시간 출력**
    - `-d` : 예약된 작업을 **삭제**, **`atrm`** 명령어 또한 같은 동작을 수행

- **사용 예시**

  ```sh
  at now + 3 hours -f elice.sh
  
  // 지금으로부터 3시간 후에 elice.sh 스크립트를 실행
  ```

### crontab

- **crontab** : 지정된 시간에 1회 실행되는 `at`과 달리, 지정된 시간에 따라 **주기적으로** 실행

  ```sh
  crontab [옵션]
  ```

  - **option**
    - `-l` : 현재 계정의 설정된 **crontab 정보**를 보여준다.
    - `-e` : 현재 계정의 crontab 정보를 **수정**한다.
    - `-r` : 현재 계정의 crontab 정보를 **모두 삭제**한다.
    - `-u` : **특정 사용자의 crontab 정보**를 다루게 해준다(root 권한 필요).

- **사용 예시**

  ```sh
  $ crontab -l
  # 매월 1일 1시 10분에 /home/elice/test/sh 실행
  10 1 1 * * /home/elice/test.sh
  # 월요일 1시, 1시 30분에 /home/elice/backup.sh 실행
  0, 30 1 * * 0 /home/elice/backup.sh
  (콤마를 통해 2가지 이상의 시간 표현 가능)
  ```

## SSH: 리눅스 원격 접속하기

- **SSH** : **Secure Shell**의 줄임말로, 네트워크를 통해 **다른 컴퓨터**에 **접근**하거나 그 컴퓨터에서 **명령 실행** 등을 할 수 있도록 해주는 프로토콜
- 즉, SSH를 통해 다른 컴퓨터에서 리눅스에 접속하여 명령어 및 프로그램을 실행할 수 있다.

#### Telnet과 SSH

- Telnet 또한 네트워크를 통해 다른 컴퓨터에 **접근**하거나 그 컴퓨터에서 **명령 실행** 등을 할 수 있도록 해주는 프로토콜이다. 하지만 보안적으로 매우 치명적인 결함이 존재한다. 
- Telnet을 통해 보내지는 패킷 데이터는 암호화 되어 있지 않다. 즉, 이를 통해 사용자의 비밀번호 등 노출 되어서는 안 되는 데이터가 노출된다. 하지만 SSH의 데이터는 **암호화** 되어 있다. 

### openssh

- 우분투에서는 **openssh**라는 패키지를 통해 SSH를 구동할 수 있다. 우분투를 설치하고 나면, **openssh-client**만이 기본적으로 설치되어 있다.
- 다른 컴퓨터에서 우분투에 접속하려면 **openssh-server** 패키지를 설치해야 한다. 

### openssh 설치

```sh
// openssh 설치 여부 확인
$ dpkg -l | grep openssh

// apt-get 명령어로 openssh-server 설치
$ sudo apt(-get) install openssh-server
```

### ssh 서버 실행하기

```sh
// ssh 서버 실행하기 (sudo 권한 필요)
$ sudo service ssh start
$ service --status-all | grep +
```

### sssh 서버 종료 및 재실행

```sh
// ssh 서버 종료 / 재실행하기
$ sudo service ssh stop / restart
```

### ssh 포트 확인하기

```sh
// ssh 포트 확인하기
// 현재 네트워크가 어떻게 열려있고 어떤 통신을 하고 있는지의 정보
$ sudo netstat -antp
```

### ssh 접속하기

```sh
// ssh 접속하기
$ ssh [서버아이디]@[아이피 혹은 서버이름 혹은 도메인]
```

- cmd 또는 터미널 창에서 다음의 명령어로 접속 가능하다. OpenSSH Client가 설치되어 있어야 한다. 

<br/>

---

※ 엘리스가 제공한 학습 자료, 콘텐츠의 저작권은 엘리스에 있습니다. <br>

**※ COPYRIGHT 2016-2021. ELICE ALL RIGHTS RESERVED.**